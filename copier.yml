# ---------
#   Common
# ---------

project_id:
  type: str
  help: Name of the google project id
  # validator: ".+"

gcp_user_account:
  type: str
  help: An email address that has google account permissions in the GCP project to give GCP resources permissions and will be used for letsencrypt certificates.
  # validator: ".+"

state_bucket:
  type: str
  help: Name of GCP bucket to store terraform and terragrunt states. Must omit the gs:// prefix.
  validator: "{% if 'gs://' in state_bucket %}Invalid format — omit gs://{% endif %}"
  # validator: ".+"

domain_name:
  type: str
  help: Base domain without protocols (e.g., example.org).
  # validator: ".+"

region:
  type: str
  help: GCP region for regional resources (e.g., us-west1).
  # validator: ".+"

zone:
  type: str
  help: GCP zone used in kube context and defaults (e.g., us-west1-b).
  # validator: ".+"

owner:
  type: str
  help: "Text label used as prefix for computational resources; helpful for cost filtering."
  default: cave
  # validator: ".+"

dns_zone:
  type: str
  help: "Cloud DNS managed zone name (e.g., em)."
  default: cave
  # validator: ".+"

vpc_name_override:
  type: str
  help: Optional — existing VPC name to use instead of newly generated
  # TODO: Check the default handling in the template

docker_registry:
  type: str
  help: Container registry for images. The default docker.io/caveconnectome is likely correct.
  default: docker.io/caveconnectome
  # validator: ".+"

# -------------
#   Local-Only
# -------------

local_environment_name:
  type: str
  help: Environment name used for the cluster folder (e.g., api, staging, prod). Default will work.
  default: api
  # validator: ".+"

local_cluster_prefix:
  type: str
  help: Short identifier used as cluster_prefix and DNS subdomain (e.g. apiv1 for apiv1.example.com), you might have several versions of a cluster from one environment, suggest to be clearly related to the local_environment_name. Default will work.
  default: apiv1
  # validator: ".+"

local_sql_instance_name:
  type: str
  help: "Cloud SQL Postgres instance name. If migrating existing data, lookup the name you have already used."
  default: "cave-{{ local_environment_name }}"
  # validator: ".+"

global_server:
  type: str
  help: URL of the global cluster without protocols.
  default: "global.{{ domain_name }}"
  # validator: ".+"

materialize_datastack:
  type: str
  help: The first datastack that you want to set up, and create a templated materialization schedule for.  You must supply answer, but is easy to change later.
  default: my_new_datastack
  # validator: ".+"

pcg_bucket_name:
  type: str
  help: The name of the bucket you set up to store PyChunkedGraph data.
  # validator: ".+"

health_annotation_align_volume:
  type: str
  help: An aligned volume name that will be used by the Annotation service for the liveliness probe
  # validator: ".+"

bigtable_instance_name:
  type: str
  help: Bigtable instance name for PyChunkedGraph. Default is fine.
  default: pychunkedgraph
  # validator: ".+"

pcg_redis_name_override:
  type: str
  help: "Optional: Name of redis instance to store PCG meshing cache data.  Default will name it based on cluster_prefix."
# TODO: Constructing the default could be put into this part of the template

bigtable_google_project:
  type: str
  help: "Optional: If your PCG bigtable instance is in another project, the name of that project. Otherwise leave blank."

skeleton_cache_cloudpath:
  type: str
  help: "Optional: if you have already setup a skeleton cache bucket, name of the path to that bucket. Note you need to uncomment this in the root.hcl file to utilize"
  validator: "{% if 'gs://' in skeleton_cache_cloudpath %}Invalid format — omit gs://{% endif %}"
  # TODO: Can put the commenting into the jinja template. Also double check bucket format, presumably without the gs.

pcg_skeleton_cache_bucket_public_read:
  type: bool
  help: "Optional: should the skeleton cache bucket be publicly readable. If true, you need to uncomment in the root.hcl file"
  default: false
  # TODO: Can put the commenting into the jinja template. Also double check bucket format, presumably without the gs.

cave_secret_name:
  type: str
  help: Name of the Google Secret Manager secret containing the CAVE token. Defaults to {{ local_environment_name }}-cave-token. You must manually create this secret before running terraform
  default: "{{ local_environment_name }}-cave-token"
  # validator: ".+"

letsencrypt_email:
  type: str
  help: "Email for Let's Encrypt certificates. Defaults to your gcp_user_account value."
  default: "{{ gcp_user_account }}"
  # validator: ".+"

materialization_dump_bucket_name:
  type: str
  help: "Optional: GCS bucket name for materialization dumps. Leave blank if not needed."
  validator: "{% if 'gs://' in materialization_dump_bucket_name %}Invalid format — omit gs://{% endif %}"
  # TODO: Double check bucket format, presumably without the gs.

materialization_upload_bucket_name:
  type: str
  help: "Optional: GCS bucket name for materialization uploads. Leave blank if not needed."
  validator: "{% if 'gs://' in materialization_upload_bucket_name %}Invalid format — omit gs://{% endif %}"
  # TODO: Double check bucket format, presumably without the gs.
    